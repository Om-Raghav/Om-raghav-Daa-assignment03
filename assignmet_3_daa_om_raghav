**SECTION A -- Short Theory**

**Q1) DP Essentials**

-   **Optimal Substructure:**\
    The problem can be broken into smaller subproblems whose optimal
    solutions can be combined to form an optimal solution for the entire
    problem.\
    *Purpose:* Enables recursion and forms the backbone of DP solutions.

-   **Overlapping Subproblems:**\
    The problem space contains subproblems that are solved multiple
    times, making it efficient to store and reuse their results rather
    than recompute.\
    *Purpose:* Justifies storing solutions, preventing duplicate work.

-   **Memoization/Tabulation:**\
    Store solutions to subproblems (memoization: top-down, tabulation:
    bottom-up) to avoid redundant computation and achieve polynomial
    time.\
    *Purpose:* Transforms exponential recursion into efficient
    polynomial algorithms by remembering solutions.

**Q2) DP vs Divide & Conquer**

  ------------ ---------------------------- -----------------------------
  Aspect       Dynamic Programming (DP)     Divide and Conquer (D&C)

  Subproblem   Subproblems overlap; solved  Subproblems are independent;
  overlap      and stored to avoid          no overlap, so answers
               recomputation                aren\'t reused

  Solution     Actively reuses previously   Doesn\'t reuse; recomputes
  reuse        solved subproblems           for each call

  Example      Fibonacci, LCS, Matrix Chain MergeSort, QuickSort, Binary
                                            Search
  ------------ ---------------------------- -----------------------------

**Q3) Principle of Optimality**

The principle of optimality states:\
*An optimal solution to a problem contains within it optimal solutions
to subproblems.*\
**Example:** The Shortest Path Problem (e.g., Bellman-Ford, Dijkstra)
satisfies this property, since every subpath of a shortest path is
itself the shortest.

**Q4) Memoization vs Tabulation**

-   **Memoization:**\
    A top-down DP approach that solves problems recursively, storing
    results as they occur (\"on demand\").

-   **Tabulation:**\
    A bottom-up approach filling the DP table iteratively, starting from
    the simplest cases up to the desired solution.

**Q5) Branch and Bound Idea**

Branch and Bound (BnB) systematically explores branches of solution
trees, evaluating only those that are potentially optimal;\
Bounding computes optimistic estimates to prune subtrees whose solutions
cannot improve upon the current best.

**SECTION B -- Algorithms & Recurrences**

**Q6) Matrix Chain Multiplication**

Given: A₁: 5×4, A₂: 4×6, A₃: 6×2, A₄: 2×7.

a\) **m\[i, j\] recurrence and base case:**\
Let d = (5, 4, 6, 2, 7) (matrix dimensions)

-   **Base:** \$ m\[i, i\] = 0 \$ for all i

-   **Recurrence:**$m\lbrack i,j\rbrack = \min_{i \leq k < j}\mspace{2mu}\left( m\lbrack i,k\rbrack + m\lbrack k + 1,j\rbrack + d_{i - 1} \cdot d_{k} \cdot d_{j} \right)$for
    \$ 1 \\leq i \< j \\leq 4 \$.

b\) **Minimum number of scalar multiplications:**\
By evaluating all parenthesizations with this recurrence, the minimum is
**124**.

**Q7) Longest Common Subsequence (X=\"ABCDGH\", Y=\"AEDFHR\")**

a\) **LCS(i, j) recurrence and base:**

-   **Base:** \$ LCS(0, j) = 0 \$ and \$ LCS(i, 0) = 0 \$

-   **Recurrence:**$LCS(i,j) = \left\{ \begin{matrix}
    1 + LCS(i - 1,j - 1), & \text{if~}X\lbrack i\rbrack = Y\lbrack j\rbrack \\
    max(LCS(i - 1,j),LCS(i,j - 1)), & \text{otherwise} \\
    \end{matrix} \right.\ $

b\) **Length of LCS:**\
The length for the given strings is **3** (\"ADH\").

**Q8) Optimal Binary Search Tree (keys: 10,20,30; p: 0.4,0.3,0.3; q=0)**

a\) **w\[i, j\] and e\[i, j\] DP recurrences and base:**

-   **w\[i,
    j\]:**$w\lbrack i,j\rbrack = \sum_{k = i}^{j}\mspace{2mu} p_{k}$

-   **Base:** \$ e\[i, i-1\] = 0 \$

-   **e\[i, j\]
    recurrence:**$e\lbrack i,j\rbrack = \underset{r = i}{\min^{j}}\mspace{2mu}\left( e\lbrack i,r - 1\rbrack + e\lbrack r + 1,j\rbrack + w\lbrack i,j\rbrack \right)$

b\) **Minimum expected search cost:**\
Evaluating all root choices, the minimum is **1.7**.

**Q9) 0/1 Knapsack - Branch & Bound (W=5; w={2,3,4,5}, p={3,4,5,6})**

a\) **Fractional upper bound formula used in pruning:**

$$ub = v + (W - w_{\text{used}}) \times \frac{p_{k + 1}}{w_{k + 1}}$$

where v = value so far, w_used = current weight, p, w = next item\'s
profit and weight.

b\) **Level-0 and Level-1 nodes (include/exclude 1st item):**

  -------------- ----------------------------- --------------------------
  Level          Choice                        (v, w, ub)

  0              Start                         (0, 0, 10.0)

  1              Include item1                 (3, 2, 9.0)

  1              Exclude item1                 (0, 0, 8.5)
  -------------- ----------------------------- --------------------------

**Calculation details:**

-   Level-0: All capacity free, take best fractional fit: 3+4+5+6=18 max
    possible, but limited by W=5. Take sorted by p/w: item2 (4/3), item1
    (3/2), item3 (5/4), item4 (6/5).

-   Level-1: After including item1, W=3 left; can next use as much of
    the next best items as possible.

**Q10) TSP -- Dynamic Programming (Held--Karp; 4 cities with distance
D)**

a\) **C\[S, j\] recurrence and answer:**

-   Let S = subset of cities including start (city 1), and j = endpoint
    city in S:

$$C\lbrack S,j\rbrack = \min_{k \in S,k \neq j}\mspace{2mu}(C\lbrack S - \{ j\},k\rbrack + D\lbrack k\rbrack\lbrack j\rbrack)$$

-   **Final answer expression:**

$$\underset{j = 2}{\min^{4}}\mspace{2mu}(C\lbrack\{ All$$

b\) **Base entries \$ C\[{k},k\] \$ for k = 2..4 with the given D:**

-   C\[{2},2\] = D = 10

-   C\[{3},3\] = D = 15

-   C\[{4},4\] = D = 20\
    (assuming D=10, D=15, D=20)


